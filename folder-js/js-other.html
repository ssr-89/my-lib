<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Справочник JavaScript</title>
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/accordion.css">
	<link rel="stylesheet" href="css/js-main.css">
	<link rel="stylesheet" href="../css/section-menu.css">
	<link rel="stylesheet" href="css/other.css">
	<script defer src="../js/script.js"></script>
	<script defer src="../js/accordion.js"></script>
	<script defer src="js/js-main.js"></script>
<body>
	<main class="main">
		<section class="section-menu">
			<div class="section-menu__container">
				<h1 class="section-menu__title title">Справочник JavaScript</h1>
				<nav class="section-menu__menu menu">
					<ul class="menu__list list">
						<li class="menu__item">
							<a class="menu__link link" href="#operator-param">Остаточные параметры, "arguments" и оператор расширения</a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#falsy">falsy - ложные значения</a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#nodejs">Node.js в VSCode</a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#lexical">Лексическое окружение (в блоках, циклах, замыкание функции)</a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
						<li class="menu__item">
							<a class="menu__link link" href="#"></a>
						</li>
					</ul>
				</nav>
				<button class="section-menu__btn btn">
					<span></span>
				</button>
			</div>
		</section>
		<section class="operator-param" id="operator-param">
			<div class="operator-param__container">
				<h2 class="operator-param__title container-title title">Остаточные параметры, "arguments" и оператор расширения</h2>
				<div class="operator-param__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Остаточные параметры <code class="accordion__code blue-code">...</code></button>
						<div class="accordion__content">
							<p class="accordion__text text">
								Если <code class="accordion__code blue-code">...</code> располагается в конце списка аргументов функции, то это «остаточные параметры».
							</p>
							<p class="accordion__text text">
								Он собирает остальные неуказанные аргументы, т.е. <i class="color-yellow">список аргументов</i> преобразует в <i class="color-yellow">массив</i>.
							</p>
							<p class="accordion__text text">
								Остаточные параметры обозначаются через три точки <code class="accordion__code blue-code">...</code>.
							</p>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									<i class="accordion__i">// Вместо args возможно указать другое имя</i><br>
									function sumAll(...args) { <i class="accordion__i">// ВАЖНО! После ...args ничего не надо прописывать, иначе вызовит ошибку</i><br>
									&nbsp;let sum = 0;<br><br>
									&nbsp;for (let arg of args) {<br>
									&nbsp;&nbsp;sum += arg;<br>
									&nbsp;}<br><br>
									&nbsp;return sum;<br>
									}<br><br>
									console.log( sumAll(1) ); <i class="accordion__i">// 1</i><br>
									console.log( sumAll(1, 2) ); <i class="accordion__i">// 3</i><br>
									console.log( sumAll(1, 2, 3) ); <i class="accordion__i">// 6</i><br>
								</code>
							</div>
							<p class="accordion__text text">
								Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.
							</p>
							<p class="accordion__text text">
								В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в массив <span class="code accordion__code blue-code">titles</span>:
							</p>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									function showName(firstName, lastName, ...titles) {<br>
									&nbsp;console.log( fistrName + ' ' + lastName ); <i class="accordion__i">// Юлий Цезарь</i><br><br>
									&nbsp;<i class="accordion__i">// Оставшиеся параметры пойдут в массив</i><br>
									&nbsp;<i class="accordion__i">// titles = ["Консул", "Император"]</i><br>
									&nbsp;console.log( titles[0] ); <i class="accordion__i">// Консул</i><br>
									&nbsp;console.log( titles[1] ); <i class="accordion__i">// Император</i><br>
									&nbsp;console.log( titles.length ); <i class="accordion__i">// 2</i><br>
									}<br><br>
									showName("Юлий", "Цезарь", "Консул", "Император");
								</code>
							</div>
							<img class="accordion__img img" src="img/other/Деструктуризация и Остаточные параметры.jpg" alt="Остаточные параметры">
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>arguments - старый способ получения всех аргументов функции</button>
						<div class="accordion__content">
							<p class="accordion__text text">
								Все аргументы функции находятся в псевдомассиве <code class="accordion__code blue-code">arguments</code> под своими порядковыми номерами.
							</p>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									function user() {<br>
									&nbsp;console.log( arguments.length );<br>
									&nbsp;console.log( arguments[0] );<br>
									&nbsp;console.log( arguments[1] );<br><br>
									&nbsp;<i class="accordion__i">// Объект arguments можно перебирать</i>
									&nbsp;<i class="accordion__i">// for (let arg of arguments) console.log(arg);</i><br>
									}<br><br>
									<i class="accordion__i">// Вывод: 2, John, Smith</i><br>
									user("John", "Smith");<br><br>
									<i class="accordion__i">// Вывод: 1, Pete, undefined (второго аргумента нет)</i><br>
									user("Pete");
								</code>
							</div>
							<p class="accordion__text text color-yellow">!!!ВАЖНО!!! У стрелочной функции нет <code class="accordion__code blue-code">arguments</code></p>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									function f() {<br>
									&nbsp;let showArg = () => console.log(arguments[0]);<br>
									&nbsp;showArg(2);<br>
									}<br><br>
									f(1); <i class="accordion__i">// arguments обращается к вышестоящей "нормальной" функции и выводит 1</i>
								</code>
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Оператор расширения <code class="accordion__code blue-code">...</code></button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text text">
									Если <code class="accordion__code blue-code">...</code> встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
								</p>
							</div>
							<h3 class="accordion__heading title"><code class="accordion__code blue-code">Math.max</code> ожидает получить список, а не один массив</h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let arr = [3, 5, 1];<br><br>
									console.log( Math.max(arr) ); <i class="accordion__i">// NaN</i>
								</code>
							</div>
							<h3 class="accordion__heading title">
								"Расширение" перебираемого <i class="color-yellow">объекта (массива)</i> в <i class="color-yellow">список аргументов</i>.
							</h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let arr = [3, 5, 1];<br><br>
									console.log( Math.max(...arr) ); <i class="accordion__i">// 5 (оператор "расширяет" массив в список аргументов)</i>
								</code>
							</div>
							<h3 class="accordion__heading title">Передача нескольких (итерируемых) объектов и комбинация с обычными значениями</h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let arr1 = [1, -2, 3, 4];<br>
									let arr2 = [8, 3, -8, 1];<br><br>
									console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); <i class="accordion__i">// 25</i>									
								</code>
							</div>
							<h3 class="accordion__heading title">Оператор расширения можно использовать и для слияния массивов:</h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let arr = [3, 5, 1];<br>
									let arr2 = [8, 9, 15];<br><br>
									let merged = [0, ...arr, 2, ...arr2];<br><br>
									console.log(merged); <i class="accordion__i">// 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)</i>
								</code>
							</div>
							<h3 class="accordion__heading title">Преобразование <i class="color-yellow">строки</i> в <i class="color-yellow">массив</i></h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let str = "Hello";<br><br>
									console.log( [...str] ); <i class="accordion__i">// H,e,l,l,o</i>
								</code>
							</div>
							<h3 class="accordion__heading title">Метод <code class="accordion__code blue-code">Array.from</code> для преобразования <i class="color-yellow">строки</i> в <i class="color-yellow">массив</i></h3>
							<p class="accordion__text text">
								<code class="accordion__code blue-code">Array.from</code> работает с псевдомассивами и итерируемыми объектами.
							</p>
							<p class="accordion__text text">
								Оператор расширения <code class="accordion__code blue-code">...</code> работает только с итерируемыми объектами.
							</p>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									let str = "Hello";<br><br>
									console.log( Array.from(str) ); <i class="accordion__i">// H,e,l,l,o</i>
								</code>
							</div>
							<h3 class="accordion__heading title">Клонирование объекта с помощью Оператора расширения <code class="accordion__code blue-code">...</code></h3>
							<div class="accordion__wrapper">
								<code class="accordion__code block">
									const admin = {<br>
									&nbsp;name: "John",<br>
									&nbsp;age: 30,<br>
									}<br><br>
									const user = {...admin}; <i class="accordion__i">// Клонирование с помощью оператора расширения</i><br>
									console.log(user); <i class="accordion__i">// { "name": "John", "age": 30, }</i><br><br>
									user.name = "Pete";<br>
									user.age = 35;<br><br>
									console.log(admin); <i class="accordion__i">// { "name": "John", "age": 30, }</i><br>
									console.log(user); <i class="accordion__i">// { "name": "Pete", "age": 35, }</i>
								</code>
							</div>
							<img class="accordion__img img" src="img/other/Остаточные параметры и оператор расширения.jpg" alt="Остаточные параметры и оператор расширения">
						</div>
					</div>
				</div>
			</div>
		</section>
		<section class="falsy" id="falsy">
			<div class="falsy__container">
				<h2 class="falsy__title container-title title"><code class="blue-code">falsy</code> ложные значения</h2>
				<div class="falsy__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller><code class="color-yellow">falsy</code> ложные значения</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text text">
									Число <code class="color-yellow">0</code>, пустая строка <code class="color-yellow">""</code>, <code class="color-yellow">null</code>, <code class="color-yellow">undefined</code> и <code class="color-yellow">NaN</code> становятся <code class="color-yellow">false</code>. Из-за этого их называют «ложными» <span class="fw-bold">«falsy»</span> значениями.
								</p>
								<p class="accordion__text text">
									Остальные значения становятся <code class="color-yellow">true</code>, поэтому их называют «правдивыми» <span class="fw-bold">«truthy»</span>.
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section class="nodejs" id="nodejs">
			<div class="nodejs__container">
				<h2 class="nodejs__title container-title title">Node.js в VSCode</h2>
				<div class="nodejs__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Node.js в VSCode</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text text">
									1. Установить <span class="fw-bold">breakpoint</span> с помощью F9
								</p>
								<p class="accordion__text text">
									2. Запуск компилятора с помощью F5 (Node.js)
								</p>
								<p class="accordion__text text">
									3. И делать прогон по шагам с помощью F11
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section class="script-console" id="script-console">
			<div class="script-console__container">
				<h2 class="script-console__title container-title title">Цикл для вывода свойств и&nbsp;их&nbsp;значений</h2>
				<div class="script-console__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Цикл для вывода свойств и&nbsp;их&nbsp;значений</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text text">
									С&nbsp;помощью данного цикла возможно в&nbsp;DevTools (F12) во&nbsp;владке &laquo;Console&raquo; прописать и&nbsp;на&nbsp;странице откроется список свойств и&nbsp;их&nbsp;значений объекта document
								</p>
								<pre class="accordion__pre">
for (var prop in document){
  document.write(prop + ": " + document[prop] +"<br> ");
}
								</pre>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section class="debugger" id="debugger">
			<div class="debugger__container">
				<h2 class="debugger__title container-title title">Команда <code class="blue-code">debugger</code> - остановка кода</h2>
				<div class="debugger__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Команда <code class="color-yellow">debugger</code> - остановка кода</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text text">
									Выполнение кода можно приостановить с&nbsp;помощью команды <code class="color-yellow">debugger</code> прямо изнутри самого кода:
								</p>
								<pre class="accordion__pre">
function hello(name) {
  let phrase = `Привет, ${name}!`;

  debugger; <i class="accordion__i">// тут отладчик остановится</i>

  say(phrase);
}
								</pre>
								<p class="accordion__text text">
									Такая команда сработает только если открыты инструменты разработки, иначе браузер ее&nbsp;проигнорирует.
								</p>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section class="lexical" id="lexical">
			<div class="lexical__container">
				<h2 class="lexical__title container-title title">Лексическое окружение</h2>
				<div class="lexical__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Лексическое окружение</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									В&nbsp;JavaScript у&nbsp;каждой выполняемой функции, блока кода и&nbsp;скрипта есть связанный с&nbsp;ними <span class="fw-bold">внутренний (скрытый) объект</span>, называемым <span class="fw-bold">лексическим окружением LexicaEnvironment</span>
								</p>
								<p class="accordion__text accordion__text--lexical text">
      						Объект состоит из&nbsp;двух частей:
								</p>
								<p class="accordion__text accordion__text--lexical text">
									1. <span class="fw-bold">Environment Record</span>&nbsp;&mdash; объект, в&nbsp;котором как свойства хранятся все локальные переменные (а&nbsp;также некоторая другая информация, такая как значение <span class="fw-bold">this</span>)
								</p>
								<p class="accordion__text accordion__text--lexical text">
									2. Ссылка на&nbsp;внешнее лексическое окружение&nbsp;&mdash; то&nbsp;есть&nbsp;то, которое соответствует коду снаружи (снаружи от&nbsp;текущих фигурных скобок)
								</p>
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Лексическое окружение и замыкание (closure) функции</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									<a target="_blank" class="lexical-link" href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">Замыкание</a>&nbsp;&mdash; это функция, которая запоминает свои внешние переменные и&nbsp;может получить к&nbsp;ним доступ. В&nbsp;некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в&nbsp;JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в <a target="_blank" class="lexical-link" href="https://learn.javascript.ru/new-function">&nbsp;Синтаксис &laquo;new Function&raquo;</a>).
								</p>
								<p class="accordion__text accordion__text--lexical text">
									То&nbsp;есть они автоматически запоминают, где были созданы, с&nbsp;помощью скрытого свойства <code class="blue-code">[[Environment]]</code>, и&nbsp;все они могут получить доступ к&nbsp;внешним переменным.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Когда на&nbsp;собеседовании фронтенд-разработчик получает вопрос: &laquo;что такое замыкание?&raquo;,&nbsp;&mdash; правильным ответом будет определение замыкания и&nbsp;объяснения того факта, что все функции в&nbsp;JavaScript являются замыканиями, и, может быть, несколько слов о&nbsp;технических деталях: свойстве <code class="blue-code">[[Environment]]</code> и&nbsp;о&nbsp;том, как работает лексическое окружение.
								</p>
								<hr>
								<p class="accordion__text accordion__text--lexical text fw-bold">
									Вложенные функции
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Вложенная функция&nbsp;&mdash; это функция, созданная внутри другой функции.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Вложенная функция может быть возвращена: либо в&nbsp;качестве свойства нового объекта (если внешняя функция создаёт объект с&nbsp;методами), либо сама по&nbsp;себе. И&nbsp;затем может быть использована в&nbsp;любом месте.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Не&nbsp;важно где, она всё так&nbsp;же будет иметь доступ к&nbsp;тем&nbsp;же внешним переменным.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Например, здесь, вложенная функция присваивается новому объекту в&nbsp;<a target="_blank" class="lexical-link" href="https://learn.javascript.ru/constructor-new">конструкторе</a>:
								</p>
								<pre class="accordion__pre">
<i class="accordion__i">// функция-конструктор возвращает новый объект</i>
function User(name) {

  <i class="accordion__i">// методом объекта становится вложенная функция</i>
  this.sayHi = function() {
    alert(name);
  };
}

let user = new User("John");
user.sayHi(); <i class="accordion__i">// у кода метода "sayHi" есть доступ к внешней переменной "name"</i>
								</pre>
								<hr>
								<p class="accordion__text accordion__text--lexical text fw-bold">
									ПОЛНЫЙ РАЗБОР НА ПРИМЕРЕ:
								</p>
								<p class="accordion__text accordion__text--lexical text">
									1. Все функции &laquo;при рождении&raquo; получают скрытое свойство <code class="blue-code">[[Environment]]</code>, которое ссылается на&nbsp;лексическое окружение места, где они были созданы. Это&nbsp;то, каким образом функции знают, где они были созданы.
								</p>
								<img class="lexical-content-list__img img" src="img/other/1-closure.jpg" alt="Первый этап действия функции">
								<p class="accordion__text accordion__text--lexical text">
									2. В&nbsp;момент вызова <code class="blue-code">makeCounter()</code> создаётся лексическое окружение, для хранения его переменных и&nbsp;аргументов. В&nbsp;данном случае лексическое окружение: <code class="blue-code">counter: undefined</code> от&nbsp;вызова <code class="blue-code">let counter = makeCounter();</code>
								</p>
								<img class="lexical-content-list__img img" src="img/other/2-closure.jpg" alt="Второй этап действия функции">
								<p class="accordion__text accordion__text--lexical text">
									3. В&nbsp;процессе выполнения <code class="blue-code">makeCounter()</code> создаётся небольшая вложенная функция.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Неважно <span class="fw-bold">Function Declaration</span> или <span class="fw-bold">Function Expression</span> всё равно получает свойство <code class="blue-code">[[Environment]]</code>, которое ссылается на&nbsp;лексическое окружение, в&nbsp;котором она была создана, в&nbsp;данном случае текущее лексическое окружение <code class="blue-code">makeCounter()</code>.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									<span class="color-red fw-bold">ВАЖНО!!!</span> На&nbsp;этом шаге внутренняя функция была создана, но&nbsp;ещё не&nbsp;вызвана. Код внутри <code class="blue-code">function() { return count++ }</code> не&nbsp;выполняется.
								</p>
								<img class="lexical-content-list__img img" src="img/other/3-closure.jpg" alt="Третий этап действия функции">
								<p class="accordion__text accordion__text--lexical text">
									4. Выполнение продолжается, вызов <code class="blue-code">makeCounter()</code> завершается, и&nbsp;результат (небольшая вложенная функция) присваивается глобальной переменной <code class="blue-code">counter()</code>:
								</p>
								<p class="accordion__text accordion__text--lexical text">
									В&nbsp;этой функции есть только одна строчка: <code class="blue-code">return count++</code>, которая будет выполнена, когда мы&nbsp;вызовем функцию.
								</p>
								<img class="lexical-content-list__img img" src="img/other/4-closure.jpg" alt="Четвёртый этап действия функции">
								<p class="accordion__text accordion__text--lexical text">
									5. При вызове <code class="blue-code">counter()</code> для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в&nbsp;самом <code class="blue-code">counter()</code> локальных переменных нет. Но&nbsp;<code class="blue-code">[[Environment]]</code> <code class="blue-code">counter</code> используется, как ссылка на&nbsp;внешнее лексическое окружение <code class="blue-code">outer</code>, которое даёт доступ к&nbsp;переменным предшествующего вызова <code class="blue-code">makeCounter</code>, где <code class="blue-code">counter</code> был создан.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Теперь, когда вызов ищет переменную <code class="blue-code">count</code>, он&nbsp;сначала ищет в&nbsp;собственном лексическом окружении (пустое), а&nbsp;затем в&nbsp;лексическом окружении предшествующего вызова <code class="blue-code">makeCounter()</code>, где и&nbsp;находит&nbsp;её.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									<span class="color-red fw-bold">ВАЖНО!!!</span> Хотя <code class="blue-code">makeCounter()</code> закончил выполнение некоторое время назад, его лексическое окружение остаётся в&nbsp;памяти, потому что есть вложенная функция&nbsp;с <code class="blue-code">[[Environment]]</code>, которая ссылается на&nbsp;него.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									В&nbsp;большинстве случаев, объект лексического окружения существует до&nbsp;того момента, пока есть функция, которая может его использовать. И&nbsp;только тогда, когда таких не&nbsp;остаётся, окружение уничтожается.
								</p>
								<img class="lexical-content-list__img img" src="img/other/5-closure.jpg" alt="Пятый этап действия функции">
								<p class="accordion__text accordion__text--lexical text">
									6. Вызов <code class="blue-code">counter()</code> не&nbsp;только возвращает значение <code class="blue-code">count</code>, но&nbsp;также увеличивает его. Обратите внимание, что модификация происходит &laquo;на&nbsp;месте&raquo;. Значение <code class="blue-code">count</code> изменяется конкретно в&nbsp;том окружении, где оно было найдено.
								</p>
								<img class="lexical-content-list__img img" src="img/other/6-closure.jpg" alt="Шестой этап действия функции">
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Лексическое окружение блока кода в цикле&nbsp;<code class="color-yellow">if</code></button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									При выполнении блока кода if&nbsp;создаётся лексическое окружение и&nbsp;содержит локальные переменные для это блока.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Всё, что создано внутри if&nbsp;доступно только внутри&nbsp;if.
								</p>
								<img class="lexical-content-list__img img" src="img/other/if-lexical.png" alt="Лексическое окружение if">
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Лексическое окружение <code class="color-yellow">for</code>, <code class="color-yellow">while</code></button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<pre class="accordion__pre">
for (let i = 0; i < 10; i++) {
  <i class="accordion__i">// У каждой итерации цикла своё собственное лексическое окружение</i>
  <i class="accordion__i">// {i: value}</i>
}

alert(i); <i class="accordion__i">// Ошибка, нет такой переменной</i>
								</pre>
								<p class="accordion__text accordion__text--lexical text">
									<code class="color-yellow">let i</code>&nbsp;визуально находится снаружи <code class="color-yellow">{...}</code>. Но&nbsp;конструкция <code class="color-yellow">for</code>&nbsp;&mdash; особенная в&nbsp;этом смысле, у&nbsp;каждой итерации цикла своё собственное лексическое окружение с&nbsp;текущим <code class="color-yellow">i</code>&nbsp;в&nbsp;нём.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									И&nbsp;так&nbsp;же, как и&nbsp;в&nbsp;<code class="color-yellow">if</code>, ниже цикла <code class="color-yellow">i</code>&nbsp;невидима.
								</p>
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Блоки кода <code class="color-yellow">{...}</code></button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									Для избежания ошибок во&nbsp;время использования одних переменных разными скриптами - лучше использовать пустые блоки <code class="color-yellow">{...}</code>.
								</p>
								<pre class="accordion__pre">
{
  <i class="accordion__i">// сделать какую-нибудь работу с локальными переменными, которые не должны быть видны снаружи</i>

  let message = "Hello";

  alert(message); <i class="accordion__i">// Hello</i>
}

alert(message); <i class="accordion__i">// Ошибка: переменная message не определена</i>
								</pre>
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>IIFE «immediately-invoked function expressions»</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									<span class="color-yellow">&laquo;immediately-invoked function expressions&raquo; (аббревиатура IIFE)</span> означает функцию, запускаемую сразу после объявления.
								</p>
								<p class="accordion__text accordion__text--lexical text">
									Ниже в примере создаётся и&nbsp;немедленно вызывается <span class="color-yellow">Function Expression</span>. Так что код выполняется сразу&nbsp;же и&nbsp;у&nbsp;него есть свои локальные переменные.
								</p>
								<pre class="accordion__pre accordion__pre--lexical">
(function() {

  let message = "Hello";

  alert(message); // Hello

})();
								</pre>
								<p class="accordion__text accordion__text--lexical text">
									Кроме скобок, существуют и&nbsp;другие пути показать JavaScript, что мы&nbsp;имеем в&nbsp;виду <span class="color-yellow">Function Expression</span>:
								</p>
								<pre class="accordion__pre">
<i class="accordion__i">// Пути создания IIFE</i>

(function() {
  alert("Скобки вокруг функции");
})();

(function() {
  alert("Скобки вокруг всего");
}());

!function() {
  alert("Выражение начинается с логического оператора NOT");
}();

+function() {
  alert("Выражение начинается с унарного плюса");
}();
								</pre>
								<p class="accordion__text accordion__text--lexical text">
									Во&nbsp;всех перечисленных случаях мы&nbsp;объявляем <span class="color-yellow">Function Expression</span> и&nbsp;немедленно выполняем его. Ещё раз заметим, что в&nbsp;настоящий момент нет необходимости писать подобный код.
								</p>
							</div>
						</div>
					</div>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>Сборка мусора</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<p class="accordion__text accordion__text--lexical text">
									Если есть вложенная функция, которая всё ещё доступна после выполнения&nbsp;<code class="color-yellow">f</code>, то&nbsp;у&nbsp;неё есть свойство <code class="color-yellow">[[Environment]]</code>, которое ссылается на&nbsp;внешнее лексическое окружение, тем самым оставляя его достижимым, &laquo;живым&raquo;:
								</p>
								<pre class="accordion__pre accordion__pre--lexical">
function f() {
  let value = 123;

  function g() { alert(value); }

  return g;
}

let g = f(); <i class="accordion__i">// g доступно и продолжает держать внешнее лексическое окружение в памяти</i>
								</pre>
								<p class="accordion__text accordion__text--lexical text">
									Если <code class="color-yellow">f()</code> вызывается несколько раз и&nbsp;возвращаемые функции сохраняются, тогда все соответствующие объекты лексического окружения продолжат держаться в&nbsp;памяти. Вот три такие функции в&nbsp;коде ниже:
								</p>
								<p class="accordion__text accordion__text--lexical text">
								</p>
								<pre class="accordion__pre">
function f() {
  let value = Math.random();

  return function() { alert(value); };
}

<i class="accordion__i">// три функции в массиве, каждая из них ссылается на лексическое окружение</i>
<i class="accordion__i">// из соответствующего вызова f()</i>
let arr = [f(), f(), f()];
								</pre>
								<p class="accordion__text accordion__text--lexical text">
									В&nbsp;следующем коде, после того как <code class="color-yellow">g</code>&nbsp;станет недоступным, лексическое окружение функции (и, соответственно, <code class="color-yellow">value</code>) будет удалено из&nbsp;памяти:
								</p>
								<pre class="accordion__pre">
function f() {
  let value = 123;

  function g() { alert(value); }

  return g;
}

let g = f(); <i class="accordion__i">// пока g существует,</i>
<i class="accordion__i">// соответствующее лексическое окружение существует</i>

g = null; <i class="accordion__i">// ...а теперь память очищается</i>
								</pre>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>
		<!--
		<section class="000" id="000">
			<div class="000__container">
				<h2 class="000__title container-title title">111</h2>
				<div class="000__block accordion" data-spollers data-one-spoller>
					<div class="accordion__item">
						<button class="accordion__title btn" data-spoller>111</button>
						<div class="accordion__content">
							<div class="accordion__wrapper">
								<pre class="accordion__pre">
									&nbsp;
								</pre>
							</div>
						</div>
					</div>
				</div>
			</div>
		</section>-->
	</main>
</body>
</html>